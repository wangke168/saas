1、签名算法飞猪提供服务接口签名算法为：（1）sign生成算法：base64(SHA256RSA2(param, "privateKey", "utf-8"))，列表参数按照字典规则升序排列,拼接时按英文逗号分割，无空格（2）privateKey：飞猪提供的privateKey（3）timestamp：当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间（格林威治时间）1970年1月1号0时0分0秒所差的毫秒数。Java语言使用：System.currentTimeMillis(); 接口十分钟内有效（4）Java JDK8 加签、验签示例：import java.security.KeyFactory;import java.security.PrivateKey;import java.security.PublicKey;import java.security.Signature;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;import java.util.Base64;/***/* SHA256withRSA 加签验签工具public class EncryptRSAToolkit {private static final String KEY_ALGORITHM = "RSA";private static final String SIGNATURE_ALGORITHM = "SHA256withRSA";/*** 加签* @param privateKey 私钥* @param requestData 请求参数* @return*/public static String sign(String privateKey, String requestData) throws Exception {byte[] byteKey = Base64.getDecoder().decode(privateKey);PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(byteKey);KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);PrivateKey privateKeyObject = keyFactory.generatePrivate(pkcs8EncodedKeySpec);Signature Sign = Signature.getInstance(SIGNATURE_ALGORITHM);Sign.initSign(privateKeyObject);Sign.update(requestData.getBytes());byte[] signed = Sign.sign();return Base64.getEncoder().encodeToString(signed);}/*** 验签* @param publicKey 公钥* @param requestData 请求参数* @param sign 签名* @return*/public static boolean verifySign(String publicKey, String requestData, String sign) throbyte[] byteKey = Base64.getDecoder().decode(publicKey);X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(byteKey);KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);PublicKey publicKeyObject = keyFactory.generatePublic(x509EncodedKeySpec);Signature verifySign = Signature.getInstance(SIGNATURE_ALGORITHM);verifySign.initVerify(publicKeyObject);verifySign.update(requestData.getBytes());return verifySign.verify(Base64.getDecoder().decode(sign));